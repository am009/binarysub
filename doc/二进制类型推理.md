#  引言

二进制类型推理是一个很重要的问题，而且目前的反编译器都无法支持自定义的结构体类型恢复。

- 二进制里使用到了复杂的语言特性
  - 多态函数：例如malloc在不同的场景下分配的是不同的类型
  - 指针类型：通过指针的不同偏移，表示结构体指针类型
  - 递归类型：结构体内包含指向自己相同结构体类型的指针。
  - 自定义的子类型：比如HGDI可以用作HBRUSH，HPEN。typedef类型也是进一步区分子类型或者父类型。

因此，为了构建完善且系统化的二进制类型推理算法，我们需要在现有最新的类型推理算法的进展上进一步支持二进制类型的特性。按照下面的几步介绍：

- 我们介绍Language-1上的类型推理：它是原始的类型推理算法SimpleSub的不考虑多态的版本。它不支持指针，所以和二进制代码差距还是很大。这部分内容回顾SimpleSub类型推理的基础。
- 然后，我们引入指针类型（Language-2），但是我们暂时不引入指针加减法运算，即我们不允许结构体类型（域非敏感，field-insensitive）。
- 然后，我们尝试将指针分析从类型推理算法中分离出来。当然，这要基于我们先观察到类型推理算法中偷偷做了指针分析这一点。
- TODO，引入指针加减法
- TODO，引入多态。

## Language-1

这部分内容主要是回顾SimpleSub，我们最基础的类型推理的起点。虽然后续不会用到结构体类型，我们暂时保留这里的结构体类型，学习相关内容有助于我们后续引入指针类型。

想象我们有下面的语法树：（注：这里的代码来自SimpleSub原文）

```scala
enum Term {
    case Lit (value: Int)                 // 例如: 27
    case Var (name: String)              // 例如: x
    case Lam (name: String, rhs: Term)  // 例如: λx. t
    case App (lhs: Term, rhs: Term)     // 例如: s t
    case Rcd (fields: List[(String, Term)]) // 例如: {a: 0; b: true; ...}
    case Sel (receiver: Term, fieldName: String) // 例如: t.a 
}
```

简单看一下，我们有常量表达式，也可以有变量表达式。然后我们可以定义函数，为了简化，只允许一个参数。函数带来的是两种语法树操作：函数定义Lam，以及函数的调用App。然后我们允许结构体类型，包括结构体类型常量的定义，以及结构体成员的访问。

> 通过语法糖，这个语言可以支持变量的定义。可以看到，我们变量似乎唯一的用法就是出现在函数的参数，没有什么语法可以让我们直接定义变量，比如`Int x = 0`。但是，通过函数定义和函数调用的组合，我们可以支持这种用法。比如我们想要定义`Int x = 0`，然后后续有一些使用到变量x的代码。对应地，我们可以定义一个函数，参数是变量x，然后里面放上后续使用到变量x的代码，然后我们直接调用这个函数，给他传入0，这样不就达到完全一样的效果了吗？总的来说，通过声明一个函数，然后立刻调用它（而且只调用一次，别的地方完全不会再用到这个函数了），我们实现了变量的定义。虽然你可能发现，x的值不能被修改，是的，我们暂时不引入可变的变量，现在说的变量是不可变的，只能在初始化的时候赋值一次。

然后我们有下面的类型定义：

```cpp
using SimpleType = std::shared_ptr<TypeNode>;
struct TypeNode { std::variant<TPrimitive, VariableState, TFunction, TRecord> v; };
struct TPrimitive { std::string name; };
struct TFunction { std::vector<SimpleType> args; SimpleType result; };
struct TRecord { std::vector<std::pair<std::string, SimpleType>> fields; };
```

其实这里的类型是为类型推理算法服务的数据结构，并不算是传统意义上标准的类型该有的样子。总之我们之后提到类型，讨论的就是它了。首先，不看变量类型的话，其他的类型都算是正常。对于简单的整数，它的类型是Primitive("Int")，对于函数，也是正常的递归存储参数和返回值类型，对于结构体类型也是和函数差不多。

但是对于变量，我们直接给他表示为节点，VariableState，它内部存储自己记录的所有的上界和下界。如果你看过SimpleSub，就会知道类型变量的上界和下界类型，分别是它所有的上界和下界的交或者并。想象一下，随着类型推理的进行，结构体类型变量，它的upperBounds里面会随着变量的成员访问，不断增加着对应的成员上界，最后把所有的成员综合一下就得到了它该有的所有成员。

```cpp
struct VariableState {
  std::vector<SimpleType> lowerBounds;
  std::vector<SimpleType> upperBounds;
};
```

类型推理的核心算法是typeTerm，它递归访问语法树，并返回当前节点的类型。另外一个重要的函数是constrain，它增加一个子类型约束。简单理解为lhs有一个数据流会流向rhs，那么lhs就得是rhs的子类型（当然也包括类型相同的情况）。因为子类型从根本的定义上就是，子类型可以在任何场景下替代父类型。

```scala
type Ctx = Map[String, SimpleType]

def typeTerm(term: Term)(implicit ctx: Ctx): SimpleType = ...

def constrain(lhs: SimpleType, rhs: SimpleType): Unit = ...
```

另外有两个辅助函数

```scala
def freshVar: Variable =
    Variable(new VariableState(Nil, Nil))

def err(msg: String): Nothing =
    throw new Exception("类型错误: " + msg)
```

基本类型推断算法的核心部分也非常的简单：

```scala
def typeTerm(term: Term)(implicit ctx: Ctx): SimpleType = term match {
    // 整数字面量：
    case Lit(n) => Primitive("int")
    // 变量引用：
    case Var(name) => ctx.getOrElse(name, err("not found: " + name))
    
    // 记录创建：
    case Rcd(fs) => Record(fs.map { case (n, t) => (n, typeTerm(t)) })
```

- 整数或者结构体的字面量，就直接对应创建并返回对应类型。
- 如果引用了变量，就到ctx里面查找。

对于函数调用，我们对参数需要创建一个新的变量了。注意到，如果函数被多次调用，那么参数就是数据流的汇聚点，从实参汇聚到形参。

```scala
// λ 抽象:
case Lam(name, body) =>
  val param = freshVar
  Function(param, typeTerm(body)(ctx + (name -> param)))
```

对于类型应用，我们同样引入一个新变量，表示函数的返回值类型，因为它是数据流的分叉点，从函数内返回到多个调用者那边。

```scala
// 应用:
case App(f, a) =>
  val res = freshVar
  constrain(typeTerm(f), Function(typeTerm(a), res))
  res
```

同时我们增加约束，f的类型是当前调用点的类型的子类型，这意味着，在constrain内部会进一步拆分成两个数据流带来的constraint调用：从typeTerm(a) -> 函数的param变量。 从typeTerm(body)流向刚创建的存储返回值的变量。

最后，结构体成员访问，我们给他增加一个单字段结构体类型的上界约束。直观来说，当前变量被当做，至少有一个成员的结构体类型来使用。另外有一个口诀是，数据流从下向上，所以是上界约束。

```scala
// 记录字段选择:
case Sel(obj, name) =>
  val res = freshVar
  constrain(typeTerm(obj), Record((name -> res) :: Nil))
  res
}
```

然后我们处理约束函数：这里有一个缓存map，记住所有已经调用过的约束，防止重复。

```cpp
using Cache = std::set<std::pair<const TypeNode *, const TypeNode *>>;

expected<void, Error> constrain(const SimpleType &lhs, const SimpleType &rhs,
                                Cache &cache, VarSupply &supply) {
  auto key = std::make_pair(lhs.get(), rhs.get());
  if (cache.find(key) != cache.end())
    return expected<void, Error>{};
  cache.insert(key);
  return constrain_impl(lhs, rhs, cache, supply);
}
```

真正的实现是在`constrain_impl`函数中。然后是匹配类型相同的情况。

> 类型不一样很可能是类型冲突。对于编程语言类型推理的时候，可以直接报错给用户，应该是用户没写对语言。但是如果是二进制类型推理，则可能是哪里出了问题，或者用户用了什么union类型。

```cpp
  if (auto lp = lhs->getAsTPrimitive()) {
    if (auto rp = rhs->getAsTPrimitive()) {
      if (lp->name == rp->name)
        return expected<void, Error>{};
      else
        return unexpected<Error>(Error::make("primitive mismatch: " + lp->name +
                                             " </: " + rp->name));
    }
  }

  if (auto lf = lhs->getAsTFunction())
    if (auto rf = rhs->getAsTFunction()) {
      if (lf->args.size() < rf->args.size()) {
        return unexpected<Error>(
            Error::make("function arity mismatch: subtype has fewer params"));
      }
      for (size_t i = 0; i < rf->args.size(); ++i) {
        if (auto e = constrain(rf->args[i], lf->args[i], cache, supply); !e)
          return e;
      }
      if (auto e = constrain(lf->result, rf->result, cache, supply); !e)
        return e;
      return expected<void, Error>{};
    }

  if (auto lr = lhs->getAsTRecord())
    if (auto rr = rhs->getAsTRecord()) {
      std::map<std::string, SimpleType> fmap;
      for (auto const &[n, t] : lr->fields)
        fmap[n] = t;
      for (auto const &[n_req, t_req] : rr->fields) {
        auto it = fmap.find(n_req);
        if (it == fmap.end())
          return unexpected<Error>(Error::make("missing field: " + n_req));
        if (auto e = constrain(it->second, t_req, cache, supply); !e)
          return e;
      }
      return expected<void, Error>{};
    }

```

对于常量类型，两边类型相同，不用做什么。不同说明程序有问题了。

对于函数类型，我们递归地约束返回值。但是参数类型要注意逆变问题了。这里涉及到的是函数的子类型关系。如果学习过类型系统，就对这一块比较了解了。

> 简单来说，比如我们有这样的类型关系：`正整数 -> 自然数 -> 整数`。原来有一个函数参数和返回值都是自然数，此时，如果有一个新的函数说，我能够替代这个函数，那么（根据定义）意味着新的函数是原来函数的子类型。
>
> 然后从新的函数角度来说，原来函数返回的是自然数，那么可以更严格要求自己，即返回正整数，因为传出去之后，正整数也可以当做自然数。从参数的角度呢，会发现是反过来的。原来的函数可以接受自然数，那么新的函数反而需要能够接受的更多，比如整数。如果新的函数只能接受正整数，那么当传入了一个自然数的时候，不就出问题了吗。

对于结构体类型，我们要求子类型要比父类型成员更多。同时都有的成员，要递归满足子类型关系。

```scala
case (Variable(lhs), rhs) =>
  lhs.upperBounds = rhs :: lhs.upperBounds
  lhs.lowerBounds.foreach(constrain(_, rhs))

case (lhs, Variable(rhs)) =>
  rhs.lowerBounds = lhs :: rhs.lowerBounds
  rhs.upperBounds.foreach(constrain(lhs, _))
```

接下来是最为精髓的函数部分，我们递归地传递上下界约束，其实这里维护了子类型的传递性，比如A->B->C，那么就增加边A->C。这意味着，根据所有的数据流的组合，把所有两两有数据流关系的节点都保存到upperBound和lowerBound里面了。把VariableState看作节点，把upperBound和lowerBound看作边，这里形成了一个子类型的关系图。

最终得到的边可能会很密集，差不多有节点的平方那么多。想象一下一个线性的变量节点之间的数据流1->2->3->4->5...，那么其中任意两两之间都有数据流关系，那么任意两个节点的组合之间都有边，边的数量就是(n^2)/2

## Language-2

基于前面的语言，我们尝试引入指针类型。

### 单一指针类型的问题

如果直接简单地引入指针类型会存在问题：

```scala
case Ptr(inner: SimpleType)
```

考虑下面的两个代码

```
// 代码1
p = q
*p = x
y = *q

// 代码2
p = q
*q = x
y = *p
```

可以看到，x的值被从一个指针存入，从另外一个指针取出，由于最开始的赋值语句，两个指针会指向相同的内存区域，因此y得到的值应该就是x存进去的值，因此存在一个x到y的数据流，同时也导致了数据流带来的子类型关系。即，x是y的子类型。

两个程序的区别仅在于，是从哪一个指针存入，哪一个指针取出的。

然后我们尝试从类型推理的角度分析x和y的子类型关系。

如果两个指针是子类型关系的话，那么指针内部指向的类型，也该是子类型吗？这代表了指针类型是协变的，我们先假设是这样。那么对于第一个赋值语句，我们有这样的关系

- q是p的子类型，表示为 `q -> p` （箭头表示数据流，即子类型指向父类型）
- 根据协变，我们有 `*q -> *p` ，即q指向的对象是p指向的对象的子类型。

然后我们看代码2，后面两个语句，利用指针指向的对象传递数据流，比如`x -> *p` 然后从另外一个对象那边取出来`*q -> y`。和之前的类型关系一起看，如果最后实现了从x到y的联通`x -> *p -> *q -> y` ，则说明我们能够考虑x到y的数据流，如果无法联通，则说明我们考虑不到这个数据流，算法存在问题。

那么此时，我们会发现，第一种情况希望存在`*q -> *p`，第二种情况希望存在`*p -> *q`，两个代码都要考虑的话，即两种子类型关系都存在，那么就有`*q == *p`，因为两个类型互为子类型，则类型相等。

此时出现了一个悖论，难道说，只要有指针赋值，则指向的类型就相等吗？这明显是不对的。问题其实出在我们对指针类型的建模上。

解决这种情况的方式是：区分指针的存储类型和加载类型！

我们定义指针为两种类型，store存储类型（记作`p.store`）和load加载类型（记作`p.load`）。比如说对于指针p，我们有`p.store -> p.load`，即每个指针的存入类型是加载类型的子类型。可以类比成getter和setter：

```
class Pointer {
	Value val;
	Value get() {return val;}
	void set(Value v1) {val = v1;}
}
```

即我们把每个指针都看作是这种类的封装，存入的时候可以存入相同类型或者子类型，但是取出来的时候当做相同类型或者父类型使用。这也意味着指针的存储类型是协变的。即，如果p和q有子类型关系，`p.store`和`q.store`的子类型关系会反过来。

我们再回来看这个例子，首先对于指针p和q，直接就隐含了下面的两个关系

```
p.store -> p.load
q.store -> q.load
```

然后我们再看第一个赋值语句，`p = q`。注意，存储类型是协变的，加载类型是逆变的。因此我们有下面的关系

```
q -> p
q.load -> p.load
q.store <- p.store
```

这一堆关系是不是很复杂？其实梳理一下是这样的：（和前面几个完全等价）

```
q -> p
p.store -> q.store -> q.load -> p.load
```

> 梳理指针类型的load、store类型的这些关系是有诀窍的。即使是有更复杂的指针赋值关系也是一样，比如说，有指针关系`p1 -> p2 -> p3`这个图，一开始的时候，我们先写store标签的指针，然后逆着指针关系走。意味着是这样`p3.store -> p2.store -> p1.store`，因为store类型是逆变的，这很合理。然后我们应用指针内含的关系`p1.store -> p1.load`，然后我们再用load标签，顺着赋值关系走回来`p1.load -> p2.load -> p3.load`。最后就可以得到最核心的子类型关系。我们这里把握的是最简的子类型关系，其他的关系都可以根据这个链条的可达性派生出来。我们的例子是线性的三个指针，更复杂的时候，指针赋值可能会出现分叉等更多情况。

> 总之，这里有三个步骤，1 拿着store标签，逆着指针的数据流走 2 从store 标签变成load标签 3 用load标签顺着子类型关系走。这样的步骤有没有什么实际的映射意义呢？
>
> 我们考虑更复杂的情况，假设有两个链条：
>
> `p1 -> p2 -> p3` 和 `p1 -> p12 -> p13`，它们的起始点都在p1。刚好我们从p3开始逆着数据流走到p1，然后顺着数据流可以走到p13。那么，有可能一开始p3指向一个对象o，然后因为指针的赋值关系，p1也指向了o，然后继续因为赋值关系，p13也指向了对象o。（因为我们没有考虑语句的顺序（流非敏感分析），因此假设语句可以任意顺序排列。）
>
> 但是如果走不到的情况：比如`p21 -> p22`  `p31 -> p22`，这种情况，从p21根据上面的三步走的方式，走不到p31的，那么，同理，根据这两个赋值关系`p22 = p21`  `p22 = p31`，那么也无法想象有一个对象一开始被p21指向，在这两个赋值语句后，会被p31指向。
>
> 所以，三步走对应的意义是，如果一开始程序中所有指针都指向独立的对象时，最终形成的类型关系。

这样就会发现，无论是从哪个存入哪个取出，因为存入都是存入的store类型，在左侧，取出都是load类型，在右侧，因此最终都可以得到x到y的通路，即成功考虑了这一数据流关系。

### 区分Load和Store类型

因此，我们引入区分的指针load和指针store类型：

```scala
enum SimpleType {
    case Variable (st: VariableState)
    case Primitive (name: String)
    case Function (lhs: SimpleType, rhs: SimpleType)
    case Record (fields: List[(String, SimpleType)])
    case PtrLoad(loadType: SimpleType)    // 只表示读取能力的指针
    case PtrStore(storeType: SimpleType)  // 只表示写入能力的指针
}
```

这里我们区分了指针的load类型和store类型，即现在指针由两个类型表示，其中存进去的类型是load类型的子类型。如上一章所示，直接简单的表示为单一的类型会影响指针相关数据流的子类型的表达能力。虽然也可以表示为单一的类型 `case Ptr(storeTy: SimpleType, loadTy: SimpleType)`，但是因为store总是出现在下界，而load类型总是出现在上界，现在这样更加简洁。

比如，正整数是自然数的子类型，因为正整数可以在用自然数的地方替代自然数，反之则不一定。一个指针可能它的存储类型是正整数，但是使用时的类型是自然数。即，存指针的时候都存的是正整数，但是使用指针的时候当自然数用。这当然是没有任何问题的。

其中，PtrStore类型是逆变的，类似函数的参数。再复习一下逆变的关系，如果指针A是指针B的子类型，那么PtrStore(B)会反过来是PtrStore(A)的子类型。你也可以把PtrStore类型类比为只有一个参数的函数，同时把PtrLoad类型类比为只有返回值的函数。

然后我们引入指针的四个基本操作：

1. 取地址

   被取地址的情况是内存分配指令，即LLVM中的alloca指令或者malloc调用。对象要么是栈对象，要么是堆对象。如果在编程语言中某个值被取地址，那么它在编译时会被强制放到内存中。

   如果是一个编程语言，则我们往往要求分配的地方直接明确写出具体的类型。此时我们就有一个Store约束，想象这个指针被存入了这个对象。

   ```scala
   // 遍历语法树的时候，如果遇到了内存分配
   case Alloca(ty) =>
       val res = freshVar
       constrain(PtrStore(ty), res)
       res
   ```

2. 指针store

   将一个值存入指针，对应的是store指令。Store指令给出的是

   ```scala
   case Store(v, ptr) =>
       constrain(PtrStore(typeTerm(v)), ptr)
   ```

   

3. 指针load

   从指针从加载值出来，此时是

   ```scala
   case Load(ptr) =>
       PtrLoad(ptr)
   ```

   

4. 指针赋值

   指针的赋值

   ```scala
   // p2 = p1
   case Assign(p1, p2) =>
       constrain(p1, p2)
   ```



最后，指针类型的引入，额外增加了一个要求，即指针存入的值会流向加载得到的值，这个数据流导致的指针关系。因此，constraint函数也需要做出改变。

为了方便，我们首先将之前的递归的添加子类型边，改成[这里](https://blog.polybdenum.com/2020/08/01/subtype-inference-by-example-part-5-incremental-reachability.html)的这种迭代式。

```
pub fn add_edge(&mut self, lhs: ID, rhs: ID, out: &mut Vec<(ID, ID)>) {
    let mut work = vec![(lhs, rhs)];

    while let Some((lhs, rhs)) = work.pop() {
        // Insert returns false if the edge is already present
        if !self.downsets[lhs].insert(rhs) {
            continue;
        }
        self.upsets[rhs].insert(lhs);
        // Inform the caller that a new edge was added
        out.push((lhs, rhs));

        for &lhs2 in self.upsets[lhs].iter() {
            work.push((lhs2, rhs));
        }
        for &rhs2 in self.downsets[rhs].iter() {
            work.push((lhs, rhs2));
        }
    }
}
```





### 指针规则带来的问题

### 指针分析

可以看这个PPT：https://xiongyingfei.github.io/SA/2016/07_pointer_analysis.pdf

**指针分析**（Pointer Analysis）是程序静态分析中的一项核心技术，是后续许多高级程序分析的基础，例如别名分析、数据流分析、内存安全检查等。它旨在确定程序运行时每个指针变量可能指向哪些内存对象。

**内存位置的抽象**：我们必须对程序中的内存对象进行**抽象建模**。在分析过程中，指针必须指向我们抽象后的内存对象，主要包括栈对象，以及堆对象。

比如我们根据分配位置（Allocation site）抽象，每个**分配语句**视为一个独立的内存对象，识别出所有分配具体对象的函数调用，比如将每个malloc函数的调用抽象为单个内存对象。每个函数上的栈空间也单独抽象为一个内存对象。创建完所有的内存对象是后续指针分析的基础。

然而，如果出现malloc函数的封装，然后程序中所有的内存分配都使用这个封装的函数，那么可能会把程序所有的对象都抽象成一个了，那么后面指针分析的结果也只会指向这个对象，这会有很大问题。此时，需要修改内存抽象的位置，根据所有的malloc封装函数的调用，去创建堆内存对象。总的来说，实际情况下很可能需要人工介入设置到正确的函数层次。

**基本的指针操作**：接下来，指针分析的基础就是收集所有的指针操作。我们暂时不考虑这些操作之间的顺序，即流非敏感。

首先，C语言中的赋值语句归结为以下四种基本形式：





| 赋值语句 | 指针分析约束（集合语义）                                     | 说明                                                     |
| -------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| `a = &b` | $ \text{pts}(a) \supseteq \{ b \} $                          | 指针 `a` 指向变量 `b` 的地址（`b` 是一个内存对象）       |
| `a = b`  | $ \text{pts}(a) \supseteq \text{pts}(b) $                    | `a` 指向 `b` 所指向的所有对象（指针拷贝）                |
| `a = *b` | $ \text{pts}(a) \supseteq \bigcup_{o \in \text{pts}(b)} \text{pts}(o) $ | `a` 指向 `b` 所指向对象的内容（间接读取）                |
| `*a = b` | $ \forall o \in \text{pts}(a),\ \text{pts}(o) \supseteq \text{pts}(b) $ | 将 `b` 所指向的对象写入 `a` 所指向的每个对象（间接写入） |



如果出现复杂的指针操作，都可以分解为这四种操作。例如：`*a = **b;`可分解为：

```Plain
c = *b;    // c ≥ ∀v ∈ b.v
d = *c;    // d ≥ ∀v ∈ c.v
*a = d;    // ∀v ∈ a. v ≥ d
```

这四个操作分别表示不同的约束，我们将它画在一个约束图中：

因此，我们可以构建约束图，并基于约束图的Worklist算法去求解指针分析。

【TODO】

### 分离指针分析

可以发现，指针分析有一部分计算很像是类型推理里面的计算。类型推理仿佛在假设每个指针都有自己独有的指向对象，基于它去计算最精确的那种类型情况。

单独分离出指针分析也有很大的好处，比如数据流分析就依赖于指针分析的结果。

首先，我们把指针分析中对象的概念引入类型分析。在出现对象创建的时候，我们不仅为它的地址创建变量，同时我们也为对象创建类型变量。

指针的类型复杂问题，根本原因是指针之间的数据流关系。我们首先把指针之间的赋值关系让指针分析去考虑，类型分析先不管了。后续指针的类型仅依赖于内部指向的对象的类型。

比如下面的场景里，

宏观上看，指针和

总的来说，我们修改为下面这样的逻辑：

- 不再区分指针的load和store类型。
- 遇到取地址的时候，
- 遇到指针load的时候，我们直接连接load的值和当前指针会指向的对象之间的数据流。
- 遇到指针store的时候，我们直接连接被store的值和指针会指向的对象之间的数据流
- 遇到指针赋值的时候，我们不进行任何操作。
